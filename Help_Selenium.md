
# Поиск элементов с помощью Selenium

Для поиска элементов на странице в **Selenium WebDriver** используются несколько стратегий, позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Существуют следующие методы поиска элементов:

- **find_element_by_id** - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
- **find_element_by_css_selector** - поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
- **find_element_by_xpath** - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
- **find_element_by_name** - поиск по атрибуту name элемента;
- **find_element_by_tag_name** - поиск элемента по названию тега элемента;
- **find_element_by_class_name** - поиск по значению атрибута class;
- **find_element_by_link_text** - поиск ссылки на странице по полному совпадению;
- **find_element_by_partial_link_text** - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

### Например, мы хотим найти кнопку со значением id="submit_button":
```python

from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit")
```


*Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, в которой вы запускали ваш скрипт. Скорее всего, вы увидите там ошибку NoSuchElementException. Она будет выглядеть следующим образом:*


**selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {"method":"id","selector":"submit"}**


*Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким id на странице нет.
Исправим локатор, чтобы наш код проходил без ошибок:*

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit_button")
```
#### Есть второй способ для поиска элементов с помощью универсального метода find_element() и полей класса By из библиотеки selenium. Пример:
```python
from selenium import webdriver

from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")
```

Можно использовать те же стратегии поиска, что и в **первом способе**. **Второй способ** более удобен для оформления архитектуры тестовых сценариев с помощью подхода Page Object Model, о котором мы будем говорить далее. Пока же предлагаем пользоваться первым методом с явным указанием способа поиска, так как он кажется нам более удобным, но ничто не мешает вам пользоваться и тем, и другим. Поля класса By, которые можно использовать для поиска:

- **By.ID** – поиск по уникальному атрибуту id элемента;
- **By.CSS_SELECTOR** – поиск элементов с помощью правил на основе CSS;
- **By.XPATH** – поиск элементов с помощью языка запросов XPath;
- **By.NAME** – поиск по атрибуту name элемента;
- **By.TAG_NAME** – поиск по названию тега;
- **By.CLASS_NAME** – поиск по атрибуту class элемента;
- **By.LINK_TEXT** – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
- **By.PARTIAL_LINK_TEXT** – поиск ссылки по частичному совпадению текста.

>**!Важно.** Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, подходящих под заданные вами параметры поиска. В этом случае **WebDriver вернет вам только первый элемент**, который встретит во время поиска по HTML. Если вам нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо использовать методы **find_elements_by**, которые мы рассмотрим чуть позже.

Иногда в статьях про Selenium WebDriver вы также будете встречать термин "локаторы", под которым подразумеваются стратегии поиска и значения, по которым должен выполняться поиск. Например, можно искать по локатору **By.ID со значением "send_button"**.




# Работа с браузером в Selenium
[comments](https://stepik.org/lesson/138920/step/3?unit=196194)

Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения кода. Поэтому обратите внимание на то что необходимо явно закрывать окно браузера в нашем коде при помощи команды **browser.quit()**. 

Каждый раз при открытии браузера **browser = webdriver.Chrome()** в системе создается процесс, который останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без оперативной памяти после запуска нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:
```python
from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()
```
Важно еще пояснить разницу между двумя командами: **browser.close()** и **browser.quit()**. 
*Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же?*

На самом деле, **browser.close()** закрывает текущее окно браузера. Это значит, что если ваш скрипт вызвал всплывающее окно, или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть. 

В свою очередь **browser.quit()** закрывает все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии. 

Подробнее можно посмотреть здесь: *Difference between webdriver.Dispose(), .Close() and .Quit().*

Будьте внимательны с этими методами и, в общем случае, всегда используйте **browser.quit()**. 

### Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше? 

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего использовать конструкцию 
```python
try/finally: 
```
```python

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()
```
Можете попробовать запустить оба примера и обратить внимание на разницу.

Подробно говорить об обработке исключений мы сейчас не будем, здесь важно понимать только то, что даже если в коде внутри блока **try** произойдет какая-то ошибка, то код внутри блока **finally** выполнится в любом случае. Советуем добавлять такую обработку ко всем своим скриптам при выполнении задач этого и следующего модулей, а в третьем модуле мы обсудим более лаконичные конструкции.

Если хотите узнать больше про исключения, как их кидать, ловить и как с ними жить, то советуем к прохождению вот этот урок:  [Ошибки и исключения](https://stepik.org/lesson/24463/step/1?unit=6771).



Здесь можно (и, кажется, нужно) использовать конструкцию **with ... as**:
```python
with webdriver.Chrome() as browser:
    browser.get(link)
    button = browser.find_element(By.ID, "submit")
    button.click()
```
Оно само избавится от ресурса по выходу из блока или при падении.



# Поиск всех необходимых элементов с помощью find_elements_by

Мы уже упоминали, что метод **find_element_by** возвращает только первый из всех элементов, которые подходят под условия поиска. Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки товаров в корзине интернет-магазина. 
*В тесте нам нужно проверить, что отображаются все выбранные для покупки товары.*
Для этого существуют методы **find_elements_by**, которые в отличие от **find_element_by** вернут список всех найденных элементов по заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество товаров. Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):
```python
# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера

browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину

add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# открываем страницу второго товара

browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину

add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements_by_css_selector(".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2
```
Набор стратегий здесь такой же, как и в случае с find_element_by:

- **find_elements_by_css_selector**;
- **find_elements_by_xpath**;
- **find_elements_by_name**;
- **find_elements_by_tag_name**;
- **find_elements_by_class_name**;
- **find_elements_by_link_text**;
- **find_elements_by_partial_link_text**.

Также для поиска нескольких элементов мы можем использовать универсальный метод **find_elements** вместе с атрибутами класса **By**:
```python
from selenium.webdriver.common.by import By


driver.find_elements(By.CSS_SELECTOR, "button.submit")
```
<span style='color:red'>!Важно.</span> Обратите внимание на важную разницу в результатах, которые возвращают методы **find_element** и **find_elements**. Если первый метод не смог найти элемент на странице, то он вызовет **ошибку NoSuchElementException**, которая прервёт выполнение вашего кода. **Второй же метод** всегда возвращает валидный результат: если ничего не было найдено, то он вернёт пустой список и ваша программа перейдет к выполнению следующего шага в коде.



# Как работать с элементами типа checkbox и radiobutton?
```python
<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">
```
Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с помощью значения **id** или значения атрибута **value**. Если вы видите на странице чекбокс с уникальным значением **name**, то можете искать по name.

Чтобы снять/поставить галочку в элементе типа **checkbox** или выбрать опцию из группы **radiobuttons**, надо указать **WebDriver** метод поиска элемента и выполнить для найденного элемента метод **click()**:
```python
option1 = browser.find_element_by_css_selector("[value='python']")
option1.click()
```

Также вы можете увидеть тег **label рядом с input**. Этот тег используется, чтобы сделать кликабельным текст, который отображается рядом с флажком. Этот текст заключен внутри тега **label**. Элемент **label** связывается с элементом **input** с помощью атрибута **for**, в котором указывается значение атрибута **id для элемента input**:
```python
<div>
  <input type="radio" id="python" name="language" checked>
  <label for="python">Python</label>
</div>
<div>
  <input type="radio" id="java" name="language">
  <label for="java">Java</label>
</div>
```
В этом случае можно также отметить нужный checkbox с помощью **WebDriver**, выполнив метод **click()** на элементе **label**.
```python
option1 = browser.find_element_by_css_selector("[for='python']")
option1.click()
```





# Метод get_attribute

Мы уже знаем, как найти нужный элемент на странице и как получить видимый пользователю текст. Для более детальных проверок в тесте нам может понадобиться узнать значение атрибута элемента. 
Атрибуты могут быть стандартными свойствами, которые понимает и использует браузер для отображения и вёрстки элементов или для хранения служебной информации, **например, name, width, height, color и многие другие**. Также атрибуты могут быть созданы разработчиками проекта для задания собственных стилей или правил.

**Значение атрибута представляет собой строку**. Если **значение атрибута отсутствует**, то это равносильно значению атрибута **равному "false"**. Давайте еще раз взглянем на страницу http://suninjuly.github.io/math.html. На ней есть radiobuttons, для которых выбрано значение по умолчанию. В автотесте нам может понадобиться проверить, что для одного из radiobutton по умолчанию уже выбрано значение. Для этого мы можем проверить значение атрибута checked у этого элемента. Вот HTML-код элемента:
```python
<input class="check-input" type="radio" name="ruler" id="peopleRule" value="people" checked>
```
## Найдём этот элемент с помощью WebDriver:
```python
people_radio = browser.find_element_by_id("peopleRule")
```
Найдём атрибут **"checked" с помощью встроенного метода get_attribute** и проверим его значение:
```python
people_checked = people_radio.get_attribute("checked")
print("value of people radio: ", people_checked)
assert people_checked is not None, "People radio is not selected by default"
```
Т.к. у данного атрибута значение не указано явно, то метод **get_attribute вернёт "true"**. Возможно, вы заметили, что **"true" написано с маленькой буквы**, — все методы WebDriver взаимодействуют с браузером с помощью JavaScript, в котором булевые значения пишутся с маленькой буквы, а не с большой, как в Python.

### Мы можем написать проверку другим способом, сравнив строки:
```python
assert people_checked == "true", "People radio is not selected by default"
```
Если атрибута нет, то метод **get_attribute вернёт значение None**. Применим метод get_attribute ко второму radiobutton, и убедимся, что атрибут отсутствует.
```python
robots_radio = browser.find_element_by_id("robotsRule")
robots_checked = robots_radio.get_attribute("checked")
assert robots_checked is None
```
Так же мы можем проверять наличие атрибута disabled, который определяет, может ли пользователь взаимодействовать с элементом. Например, в предыдущем задании на странице с капчей для роботов JavaScript устанавливает атрибут disabled у кнопки Submit, когда истекает время, отведенное на решение задачи.
```python
<button type="submit" class="btn btn-default" disabled>Submit</button>
```



# Работа со списками

На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных особенностей:

- У каждого элемента списка обычно есть уникальное значение атрибута value
- В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
- Визуально списки могут различаться тем, что в одном случае - варианты скрыты в [выпадающем меню](http://sun-ly.github.io/selects1.html), а в другом все варианты или их часть [видны](http://suninjuly.github.io/selects2.html)

Но для взаимодействия с любым вариантом списка мы будем использовать одни и те же методы Selenium.

 

## Посмотрим, как выглядит html для списка:

```python
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
 <option selected>--</option>
 <option value="1">Python</option>
 <option value="2">Java</option>
 <option value="3">JavaScript</option>
</select>
```

Варианты ответа задаются тегом option, значение value может отсутствовать. Можно отмечать варианты с помощью обычного метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся, а затем кликнуть на нужный вариант ответа:
```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get(link)


browser.find_element_by_tag_name("select").click()
browser.find_element_by_css_selector("option:nth-child(2)").click()
```
### Последняя строчка может выглядеть и так:
```python
browser.find_element_by_css_selector("[value='1']").click()
```
**Это не самый удобный способ, так как нам приходится делать лишний клик для открытия списка.**

**Есть более удобный способ**, для которого используется **специальный класс Select из библиотеки WebDriver**. 
- Вначале мы должны инициализировать новый объект, передав в него WebElement с тегом select. 
- Далее можно найти любой вариант из списка с помощью метода **select_by_value(value)**:

```python
from selenium.webdriver.support.ui import Select
select = Select(browser.find_element_by_tag_name("select"))
select.select_by_value("1") # ищем элемент с текстом "Python"
```

Можно использовать еще два метода: **select.select_by_visible_text("text")** и **select.select_by_index(index)**. 
- Первый способ ищет элемент по видимому тексту, например, **select.select_by_visible_text("Python")** найдёт "Python" для нашего примера.
- Второй способ ищет элемент по его индексу или порядковому номеру. Индексация начинается с нуля. Для того чтобы найти элемент с текстом "Python", нужно использовать **select.select_by_index(1)**, так как опция с индексом 0 в данном примере имеет значение по умолчанию равное "--".



# Метод execute_script

Рассмотрим еще один очень полезный и мощный метод, но он требует хотя бы минимальных знаний JavaScript. С помощью метода **execute_script** можно выполнить программу, написанную на языке JavaScript, как часть сценария автотеста в запущенном браузере. *Зачем это может понадобиться, если в автотестах мы стараемся взаимодействовать с интерфейсом сайта как обычный пользователь, нажимая кнопки, выбирая пункты меню и вводя текст в текстовые поля?*

Дело в том, что **стандартные методы, доступные в Selenium, не могут** покрыть всех возможных ситуаций работы с веб-приложением. 
- Сайты в интернете могут решать самые разные задачи, начиная от простого блога до сложных финансовых или графических приложений. 
- Разработчики имеют доступ к огромному количеству различных библиотек для решения бизнес-сценариев, что приводит к появлению на веб-странице нестандартных редакторов текстов, уникальных меню, оригинальных видео-плееров и т.д.
- Порой это приводит к тому, что для нажатия вроде бы обычной кнопки тестировщику понадобится писать настоящий JavaScript-сценарий.
- Если вы столкнулись с такой ситуацией, то в первую очередь обратитесь за помощью к вашим фронтенд-разработчикам, чтобы они подсказали  пример нужного скрипта.
- Прежде чем использовать данный скрипт в тестах, вы можете проверить, как он работает прямо в браузере, выполнив код в консоли браузера. Затем можете добавить его в ваш автотест с помощью **execute_script(javascript_code)**.

### Давайте попробуем вызвать alert в браузере с помощью WebDriver. Пример сценария:
```python
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")
```
Обратите внимание, что исполняемый **JavaScript** нужно заключать в кавычки **(двойные или одинарные)**. Если внутри скрипта вам также понадобится использовать кавычки, а для выделения скрипта вы уже используете двойные кавычки, **то в скрипте следует поставить одинарные**:
```python
browser.execute_script("document.title='Script executing';")
```
Такой формат записи тоже будет работать:
```python
browser.execute_script('document.title="Script executing";')
```
Можно с помощью этого метода выполнить сразу несколько инструкций, перечислив их через точку с запятой. Изменим сначала заголовок страницы, а затем вызовем alert:
```python
browser.execute_script("document.title='Script executing';alert('Robots at work');")
```

#### Вдруг будет кому-нибудь интересно. Выполнение JavaScript на странице - это неописанный в документации Selenium способ поиска элемента.
Вместо встроенных find_element_by... можно использовать вот такую конструкцию:
```python
element = browser.execute_script('document.getElementsByName("name")')
```
#### Так же есть конструкции:
- - getElementById
- - getElementsByTagName
- - getElementsByClassName
- - querySelector - для CSS
- - querySelectorAll - для CSS (находит все совпадения)
- - #
- - evaluate - для XPATH.

## есть 2-3 незатронутые темы. Вот они: 
- 1) я уже сталкивался с написанием тестов для django-проектов, которые использовали Angular -  и вот там, кажется, из-за "динамизма" Selenium бессилен.
- 2) столкнувшись с существованием Seleinum IDE, уже при движке F-fox-а Quantum (я думаю, Вы в курсе этой проблемы), я нашел Katalon IDE(/Studio), где с кодогенерацией на python все хорошо. Хорошо было бы бы :-)  , если бы Вы затронули и эту тему (обоих IDE).
- 3) что-нибудь на тему django/flask/ django-cms/dj-oscar  + Selenium можно? Я понимаю, что это уж слишком, и буду весьма благодарен и только за п. 1, 2. 
- 4) Наверно вообще для Степика просто курс по django бы не помешал (про курс "веб-технологии" знаю, но он не слишком хорош), и отдельно курс про многопоточность в python тоже хотелось бы (это уже к команде Степика, а не к Вам).

 **для vue.js можно cypress использовать. Как vue с Selenium дружит - сложно сказать, у нас фронтенд на ember - проблемы есть с асинхронностью, но они преодолимы**

# Пример задачи для execute_script


Давайте теперь рассмотрим реальную ситуацию, когда пользователь должен кликнуть на элемент, который внезапно оказывается перекрыт другим элементом на странице.

Для клика в WebDriver мы используем метод click(). Если элемент оказывается перекрыт другим элементом, то наша программа вызовет следующую ошибку:
```python
selenium.common.exceptions.WebDriverException: Message: unknown error: Element <button type="submit" class="btn btn-default" style="margin-bottom: 1000px;">...</button> is not clickable at point (87, 420). Other element would receive the click: <p>...</p>
```
Из описания ошибки можно понять, что указанный нами элемент нельзя кликнуть в данной точке, т.к. клик произойдёт на другом элементе с тегом **<p>**.

### Чтобы увидеть пример данной ошибки, запустите следующий скрипт:
```python
from selenium import webdriver

browser = webdriver.Chrome()
link = "https://SunInJuly.github.io/execute_script.html"
browser.get(link)
button = browser.find_element_by_tag_name("button")
button.click()
assert True
```
Теперь вы можете сами посмотреть на эту страницу и увидеть, что огромный футер действительно перекрывает нужную нам кнопку. Футером (footer) называется нижний блок, который обычно одинаков для всех страниц сайта. Чтобы понять, как решить эту проблему, нужно разобраться, как работает метод **click()**.

В первую очередь WebDriver проверит, что ширина и высота элемента больше 0, чтобы по нему можно было кликнуть.

Затем, если элемент находится за границей окна браузера, WebDriver автоматически проскроллит страницу, чтобы элемент попал в область видимости, то есть не находился за границей экрана. Но это не гарантирует того, что элемент не перекрыт другим элементом, который тоже находится в области видимости.

#### А в какую точку элемента будет происходить клик?
Selenium рассчитывает координаты центра элемента и производит клик в вычисленную точку. Это тоже приведёт к ошибке, если часть элемента всё-таки видна, но элемент перекрыт больше чем на половину своей высоты или ширины.

Если мы столкнулись с такой ситуацией, мы можем заставить браузер дополнительно проскроллить нужный элемент, чтобы он точно стал видимым.
Делается это с помощью следующего скрипта:
```python
"return arguments[0].scrollIntoView(true);"
```
Мы дополнительно передали в метод scrollIntoView аргумент true, чтобы элемент после скролла оказался в области видимости. Другие возможные параметры метода можно посмотреть [здесь:](https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView)

В итоге, чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:
```python
button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()
```
В метод execute_script мы передали текст js-скрипта и найденный элемент button, к которому нужно будет проскроллить страницу. После выполнения кода элемент button должен оказаться в верхней части страницы. Подробнее о методе [см](https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView)

Также можно проскроллить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу на 100 пикселей вниз:
```python
browser.execute_script("window.scrollBy(0, 100);")
```
<span style='color:red'>!Важно.</span> Мы не будем в этом курсе изучать, как работает JavaScript, и обойдемся только приведенным выше примером скрипта с прокруткой страницы. Для сравнения приведем скрипт на этом языке, который делает то же, что приведенный выше пример для WebDriver:
```python
// javascript
button = document.getElementsByTagName("button")[0];
button.scrollIntoView(true);
```
Можете попробовать исполнить его в консоли браузера на [странице](http://suninjuly.github.io/execute_script.html). Для этого откройте инструменты разработчика в браузере, перейдите на вкладку **консоль  (console)**, скопируйте туда этот код и нажмите Enter. Таким образом можно протестировать кусочки js кода прежде чем внедрять его в свои тесты на python. 

Обратите внимание, что в коде в WebDriver нужно использовать ключевое слово **return**. Также его нужно будет использовать, когда вы захотите получить какие-то данные после выполнения скрипта. При этом при тестировании скрипта в консоли браузера слово **return** использовать не надо.


# Загрузка файлов

﻿Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод send_keys. Только теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.

Чтобы указать путь к файлу, можно использовать стандартный модуль Python для работы с операционной системой — **os**. В этом случае ваш код не будет зависеть от операционной системы, которую вы используете. Добавление файла будет работать **и на Windows, и на Linux, и даже на MaсOS**.

Пример кода, который позволяет указать путь к файлу **'file.txt'**, находящемуся в той же папке, что и скрипт, который вы запускаете:
```python
import os 

current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла 
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)
```
Попробуйте добавить в файл отдельно команды 
```python
print(os.path.abspath(__file__)) 
print(os.path.abspath(os.path.dirname(__file__)))
```
и посмотрите на разницу. Подробнее о методах модуля os можете почитать самостоятельно в [документации:](https://docs.python.org/3/library/os.path.html). Обратите внимание, что это будет работать только при запуске кода из файла, **в интерпретаторе не сработает**.

### Если совсем непонятно что происходит, пример: 

Допустим, мы написали код скрипта и сохранили код в **lesson2_step7.py** в свой локальной папке **D:\stepik_homework**. Активируем виртуальное окружение и запускаем его **python lesson2_step7.py**. В таком случае конструкция 
```python
os.path.abspath(os.path.dirname(__file__)) 
```
вернет нам путь до директории файла с кодом, то есть **D:\stepik_homework**. В эту же папку кладем файл, который хотим прикрепить, то есть **file.txt**. Тогда, после выполнения команды:
```python
file_path = os.path.join(current_dir, 'file.txt')
```
В переменной file_path будет полный путь к файлу **'D:\stepik_homework\file.txt'**. Фишка в том, что если мы файлы **lesson2_step7.py** вместе с **file.txt** перенесем в другую папку, или на компьютер с другой ОС, то такой код без правок заработает и там. 

 

Элемент в форме, который выглядит, как кнопка добавления файла, имеет атрибут **type="file"**. Мы должны сначала найти этот элемент с помощью селектора, а затем применить к нему метод **send_keys(file_path)**.



### Alerts и как с ними жить

Мы уже встречали alert** в нашем курсе, когда получали число-ответ в задачах. Также мы узнали, что можно самостоятельно вызвать alert с помощью **JavaScript**:
```python
alert('Hello!');
```
<img alt="" src="https://ucarecdn.com/1f26a205-5040-46bb-a416-c8d02655fc3a/" width="451" height="137">
Теперь рассмотрим ситуацию, когда в сценарии теста возникает необходимость не только получить содержимое **alert**, но и нажать кнопку OK, чтобы закрыть **alert**. 
**Alert** является модальным окном: это означает, что пользователь не может взаимодействовать дальше с интерфейсом, пока не закроет **alert**. Для этого нужно сначала переключиться на окно с **alert**, а затем принять его с помощью команды **accept()**:
```python
alert = browser.switch_to.alert
alert.accept()
```
Чтобы получить текст из **alert, используйте свойство text объекта alert**:
```python
alert = browser.switch_to.alert
alert_text = alert.text
```
Другой вариант модального окна, который предлагает пользователю выбор согласиться с сообщением или отказаться от него, называется **confirm**. Для переключения на окно confirm используется та же команда, что и в случае с **alert**:
```python
confirm = browser.switch_to.alert
confirm.accept()
```
<img alt="" src="https://ucarecdn.com/52f90c5a-b04e-4387-8e3e-eae80d8d3f2c/" width="450" height="137">
Для **confirm-окон** можно использовать следующий **метод для отказа**:
```python
confirm.dismiss()
```
То же самое, что и при нажатии пользователем кнопки "Отмена". 

Третий вариант модального окна — **prompt — имеет дополнительное поле для ввода текста**. Чтобы ввести текст, используйте метод **send_keys()**:
```python
prompt = browser.switch_to.alert
prompt.send_keys("My answer")
prompt.accept()
```
<img alt="" src="https://ucarecdn.com/9a1f5aa3-d1b6-42c0-b340-a18e966c7a1b/" width="448" height="182">


**pyperclip** помог, спасибо!
```python
alert = browser.switch_to.alert
alert_text = alert.text
addToClipBoard = alert_text.split(': ')[-1]
pyperclip.copy(addToClipBoard)
```
и число в буфере обмена.

### а как обратиться теперь к этому числу в буфере?

забрать результат из **alert**
```python
alert_text.split(': ')[-1]
```
юзай эту [библиотеку](https://pypi.org/project/pyperclip/)

Как то так:
выполнения команды:
```python
>>> import pyperclip
>>> pyperclip.copy('The text to be copied to the clipboard.')
>>> pyperclip.paste()
'The text to be copied to the clipboard.'
```

Только зачем, если из теста вставлять число в ответ, то просто используй .send_keys(имя_переменной_с_результатом) и **pyperclip** с буфером обмена не нужен. [Вот](https://github.com/VitaliyYa/sendToStepik) как я делал.
P.S ADD [sendToStepik auth](https://github.com/VitaliyYa/sendToStepik/blob/master/auth.py)

### Сопоставьте типы модальных окон в браузере с методами WebDriver для взаимодействия с ним:

<img alt="" src="/[img]/alert.png" width="605" height="154">

**pyperclip** И она очень крута! После нее можно поставить **alert.accept()** и поставить **time.sleep(0)** или вообще не прописывать, и тогда все пройдет максимально быстро.



# Переход на новую вкладку браузера

При работе с веб-приложениями приходится переходить по ссылкам, которые открываются в новой вкладке браузера. **WebDriver может работать только с одной вкладкой браузера**. При открытии новой вкладки WebDriver продолжит работать со старой вкладкой. Для переключения на новую вкладку надо явно указать, на какую вкладку мы хотим перейти. Это делается с помощью команды **switch_to.window**:
```python
browser.switch_to.window(window_name)
```
Чтобы **узнать имя новой вкладки**, нужно использовать метод **window_handles**, который возвращает массив имён всех вкладок. Зная, что в браузере теперь открыто две вкладки, выбираем вторую вкладку:
```python
new_window = browser.window_handles[1]
```
Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:
```python
first_window = browser.window_handles[0]
```
После переключения на новую вкладку поиск и взаимодействие с элементами будут происходить уже на новой странице.




# Как работают методы get и find_element

*Разберем еще один простой тест на WebDriver, проверяющий работу кнопки*.

Тестовый сценарий выглядит так:

- Открыть страницу http://suninjuly.github.io/wait1.html
- Нажать на кнопку "Verify"
- Проверить, что появилась надпись "Verification was successful!"

Для **открытия страницы мы используем метод get**, затем находим нужную кнопку с помощью одного из методов **find_element_by_** и нажимаем на нее с помощью метода **click**. Далее находим новый элемент с текстом и проверяем соответствие текста на странице ожидаемому тексту.

Вот как выглядит код автотеста:
```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element_by_id("verify")
button.click()
message = browser.find_element_by_id("verify_message")

assert "successful" in message.text
```
Попробуйте сначала выполнить тест вручную, а затем запустить автотест. 
- В первом случае, вы завершите тест успешно
- Bо втором случае автотест упадет с сообщением **NoSuchElementException для элемента c id="verify"**. 

### Почему так происходит?

Команды в Python выполняются синхронно, то есть, строго последовательно. **Пока не завершится команда get**, не начнется поиск кнопки. Пока кнопка не найдена, не будет сделан клик по кнопке и так далее.

Но тест будет работать **абсолютно стабильно**, только **если** в данной веб-странице **не используется JavaScript** (что **маловероятно** для современного веба). 
Метод **get** дожидается информации от браузера о том, что страница загружена, и только после этого наш тест переходит к поиску кнопки. Если страница интерактивная, то браузер будет считать, что страница загружена, при этом продолжат выполняться загруженные браузером скрипты. 
**Скрипт может управлять** появлением кнопки на странице и **показывать** ее, например, **с задержкой**, чтобы кнопка красиво и медленно возникала на странице. 
В этом случае наш **тест упадет** с уже известной нам ошибкой **NoSuchElementException**, так как в момент выполнения команды **button = browser.find_element_by_id("verify")** элемент с **id="verify"** еще не отображается на странице. На данной странице пауза перед появлением кнопки установлена на **1 секунду, метод find_element_by_id() сделает только одну попытку найти элемент и в случае неудачи уронит наш тест**.




# Давайте быстрее это починим: time.sleep()

Теперь, когда мы уже знаем, что кнопка появляется с задержкой, мы можем добавить паузу до начала поиска элемента. Мы уже использовали библиотеку time ранее. Давайте применим ее и сейчас:
```python
from selenium import webdriver
import time

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

time.sleep(1)
button = browser.find_element_by_id("verify")
button.click()
message = browser.find_element_by_id("verify_message")

assert "successful" in message.text
```
Теперь тест проходит. Но что если элемент с сообщением тоже будет появляться с задержкой? Добавить еще один **time.sleep()** перед поиском сообщения? 
**А если изменится время задержки при появлении кнопки?** Увеличим длительность паузы? А еще на разных машинах с разной скоростью интернета кнопка может появляться через разные промежутки времени. Можно перед каждым действием добавить задержку, но тогда значительную часть времени прогона тестов будут занимать бесполезные ожидания, **при этом с увеличением количества тестов эта проблема будет только расти.**



# Есть способы получше: Selenium Waits (Implicit Waits)

Надеемся, вы поняли, что решение с **time.sleep()** плохое: оно не масштабируемое и трудно поддерживаемое.

Идеальное решение могло бы быть таким: нам всё равно надо избежать ложного падения тестов из-за асинхронной работы скриптов или задержек от сервера, поэтому мы будем ждать появление элемента на странице в течение заданного количества времени (например, 5 секунд). Проверять наличие элемента будем каждые 500 мс. Как только элемент будет найден, мы сразу перейдем к следующему шагу в тесте. Таким образом, мы сможем получить нужный элемент в идеальном случае сразу, в худшем случае за 5 секунд.

В Selenium WebDriver есть специальный способ организации такого ожидания, который позволяет задать ожидание при инициализации драйвера, чтобы применить его ко всем тестам. Ожидание называется **неявным (Implicit wait)**, так как его не надо явно указывать каждый раз, когда мы выполняем поиск элементов, оно автоматически будет применяться при вызове каждой последующей команды.

Улучшим наш тест с помощью неявных ожиданий. Для этого нам нужно будет убрать **time.sleep()** и добавить одну строчку с методом **implicitly wait**:
```python
from selenium import webdriver

browser = webdriver.Chrome()
# говорим WebDriver искать каждый элемент в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element_by_id("verify")
button.click()
message = browser.find_element_by_id("verify_message")

assert "successful" in message.text
```
Теперь мы можем быть уверены, что при небольших задержках в работе сайта наши тесты продолжат работать стабильно. На каждый вызов команды **find_element** WebDriver будет ждать 5 секунд до появления элемента на странице прежде, чем выбросить исключение **NoSuchElementException**.


# Про Exceptions

Теперь мы знаем, как настроить ожидание поиска элемента. Во время поиска WebDriver каждые 0.5 секунды проверяет, появился ли нужный элемент в DOM-модели браузера (**Document Object Model** — «объектная модель документа», интерфейс для доступа к HTML-содержимому сайта). Если произойдет ошибка, то WebDriver выбросит одно из следующих исключений (**exceptions**):

- Если элемент не был найден за отведенное время, то мы получим NoSuchElementException.
- Если элемент был найден в момент поиска, но при последующем обращении к элементу DOM изменился, то получим **StaleElementReferenceException**. Например, мы нашли элемент Кнопка и через какое-то время решили выполнить с ним уже известный нам метод **click**. Если кнопка за это время была скрыта скриптом, то метод применять уже бесполезно — элемент "устарел" (stale) и мы увидим исключение.
- Если элемент был найден в момент поиска, но сам элемент невидим (например, имеет нулевые размеры), и реальный пользователь не смог бы с ним взаимодействовать, то получим **ElementNotVisibleException**.

Знание причин появления исключений помогает отлаживать тесты и понимать, где находится баг в случае его возникновения.


# Explicit Waits (WebDriverWait и expected_conditions)

В предыдущем шаге мы решили проблему с ожиданием элементов на странице. Однако методы **find_element** проверяют только то, что элемент появился на странице. В то же время элемент может иметь дополнительные свойства, которые могут быть важны для наших тестов. Рассмотрим пример с кнопкой, которая отправляет данные:

- Кнопка может быть неактивной, то есть её нельзя кликнуть;
- Кнопка может содержать текст, который меняется в зависимости от действий пользователя. Например, текст "Отправить" после нажатия кнопки поменяется на "Отправлено";
- Кнопка может быть перекрыта каким-то другим элементом или быть невидимой.

**Если мы хотим в тесте кликнуть на кнопку, а она в этот момент неактивна, то WebDriver все равно проэмулирует действие нажатия на кнопку, но данные не будут отправлены.**

*Давайте попробуем запустить следующий тест:*
```python
from selenium import webdriver

browser = webdriver.Chrome()
# говорим WebDriver ждать все элементы в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait2.html")

button = browser.find_element_by_id("verify")
button.click()
message = browser.find_element_by_id("verify_message")

assert "successful" in message.text
```
Мы видим, что WebDriver смог найти кнопку с **id="verify"** и кликнуть по ней, **но тест упал** на поиске элемента **"verify_message"** с итоговым сообщением:
```python
no such element: Unable to locate element: {"method":"id","selector":"verify_message"}
```
Это произошло из-за того, что WebDriver быстро нашел кнопку и кликнул по ней, хотя кнопка была еще неактивной. На странице мы специально задали программно **паузу в 1 секунду** после загрузки сайта перед активированием кнопки, **но неактивная кнопка в момент загрузки — обычное дело для реального сайта**.

**Чтобы тест был надежным**, нам нужно не только найти кнопку на странице, но и дождаться, когда кнопка станет кликабельной. 
**Для реализации** подобных ожиданий в Selenium WebDriver **существует понятие явных ожиданий (Explicit Waits)**, которые позволяют задать специальное ожидание для конкретного элемента. Задание явных ожиданий реализуется с помощью инструментов WebDriverWait и expected_conditions. *Улучшим наш тест:*
```python
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver

browser = webdriver.Chrome()

browser.get("http://suninjuly.github.io/wait2.html")

# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной
button = WebDriverWait(browser, 5).until(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
button.click()
message = browser.find_element_by_id("verify_message")

assert "successful" in message.text
```
Как вы видите, **в этом случае нужно использовать поиск элементов с помощью класса By**, который мы рассмотрели ранее. **element_to_be_clickable вернет элемент, когда он станет кликабельным, или вернет False** в ином случае.

Обратите внимание, что в объекте WebDriverWait используется функция **until**, в которую передается правило ожидания, элемент, а также значение, по которому мы будем искать элемент. **В модуле expected_conditions есть много** других правил, которые позволяют реализовать необходимые ожидания:

- title_is
- title_contains
- presence_of_element_located
- visibility_of_element_located
- visibility_of
- presence_of_all_elements_located
- text_to_be_present_in_element
- text_to_be_present_in_element_value
- frame_to_be_available_and_switch_to_it
- invisibility_of_element_located
- element_to_be_clickable
- staleness_of
- element_to_be_selected
- element_located_to_be_selected
- element_selection_state_to_be
- element_located_selection_state_to_be
- alert_is_present

*Описание каждого правила можно найти на* [сайте](https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions).

Если мы захотим **проверять, что кнопка становится неактивной после отправки данных, то** можно задать негативное правило с помощью метода **until_not**
```python
# говорим Selenium проверять в течение 5 секунд пока кнопка станет неактивной
button = WebDriverWait(browser, 5).until_not(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
```

**В linux есть такая штука как cron (крон)** - это планировщик заданий, который работает на Unix\Linux машине. 
Он позволяет автоматически выполнять определенные действия на пк (запуск программ, скриптов и т.д.), с заданным временем или периодичностью.

При помощи него вы можете выставить любой скрипт и задать ему частоту выполнения, например 1 раз в минуту, чтобы скрипт каждую минуту автоматически запускался и проверял вашу инфу.

Для этого нужно:
```python
#  1. Сделать скрипт исполняемым - 

chmod u+x /path/to/script.py

#  2. Запустить cron

crontab -e 

#  3. Впишите эту строку

*/1 * * * * /path/to/script.py 
```
# методы Selenium Webdriver

<img alt="" src="/[img]/methods.png" width="817" height="386">


<img alt="" src="/[img]/methods1.png" width="811" height="406">

# Справочники
[7.39. Expected conditions Support](https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions)



<span><p>ссылки на ресурсы, где вы сможете найти дополнительную информацию по использованию Selenium и о&nbsp;тонкостях при&nbsp;работе с ним:</p>

<p><strong>Общее</strong></p>

<ul>
  <li><a href="https://selenium-python.com/" rel="nofollow noopener noreferrer" target="_blank">https://selenium-python.com/</a></li>
  <li><a href="http://selenium-python.readthedocs.io/" rel="nofollow noopener noreferrer" target="_blank" title="Link: http://selenium-python.readthedocs.io">http://selenium-python.readthedocs.io</a></li>
  <li><a href="http://chromedriver.chromium.org/getting-started" rel="nofollow noopener noreferrer" target="_blank" title="Link: http://chromedriver.chromium.org/getting-started">http://chromedriver.chromium.org/getting-started</a>﻿</li>
  <li><a href="https://www.guru99.com/selenium-tutorial.html" rel="nofollow noopener noreferrer" title="Link: https://www.guru99.com/selenium-tutorial.html" target="_blank">﻿https://www.guru99.com/selenium-tutorial.html</a>&nbsp;— ﻿Туториал на английском, ориентирован на Java.﻿</li>
  <li><a href="https://www.guru99.com/live-selenium-project.html" rel="nofollow noopener noreferrer" title="Link: https://www.guru99.com/live-selenium-project.html" target="_blank">https://www.guru99.com/live-selenium-project.html</a>&nbsp;— ﻿Можно попробовать писать автотесты для демо-сайта ﻿банка. Тоже Java.</li>
  <li><a href="http://barancev.github.io/good-locators/" rel="noopener noreferrer nofollow" target="_blank">http://barancev.github.io/good-locators/</a>&nbsp;— что такое хорошие селекторы</li>
  <li><a href="http://barancev.github.io/what-is-path-env-var/" rel="noopener noreferrer nofollow" target="_blank">http://barancev.github.io/what-is-path-env-var/</a>&nbsp;— что за PATH переменная?&nbsp;</li>
</ul>

<p><strong>Ожидания в Selenium WebDriver</strong></p>

<ul>
  <li><a href="https://docs.seleniumhq.org/docs/04_webdriver_advanced.jsp" rel="nofollow noopener noreferrer" style="font-size: inherit; font-weight: inherit;" title="Link: https://docs.seleniumhq.org/docs/04_webdriver_advanced.jsp" target="_blank">https://docs.seleniumhq.org/docs/04_webdriver_advanced.jsp</a></li>
  <li><a href="https://selenium-python.readthedocs.io/waits.html" rel="nofollow noopener noreferrer" title="Link: https://selenium-python.readthedocs.io/waits.html" target="_blank">https://selenium-python.readthedocs.io/waits.html</a>﻿</li>
  <li><a href="https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions" rel="nofollow noopener noreferrer" target="_blank">https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_condition...</a>﻿</li>
  <li><a href="https://stackoverflow.com/questions/15122864/selenium-wait-until-document-is-ready" rel="noopener noreferrer nofollow" target="_blank">https://stackoverflow.com/questions/15122864/selenium-wait-until-document-is-ready</a></li>
  <li><a href="https://blog.codeship.com/get-selenium-to-wait-for-page-load/" rel="noopener noreferrer nofollow" target="_blank">https://blog.codeship.com/get-selenium-to-wait-for-page-load/</a></li>
  <li><a href="http://barancev.github.io/slow-loading-pages/" rel="noopener noreferrer nofollow" target="_blank">http://barancev.github.io/slow-loading-pages/</a></li>
  <li><a href="http://barancev.github.io/page-loading-complete/" rel="noopener noreferrer nofollow" target="_blank">http://barancev.github.io/page-loading-complete/</a></li>
</ul></span>


## А чем отличаются text_to_be_present_in_element  от text_to_be_present_in_element_value ?

- **text_to_be_present_in_element** ожидает появление элемента, ищет его по текстовому значению. мы уже использовали этот метод в задании, когда бронировали дом и ждали, пока цена упадет до 100$.
- **text_to_be_present_in_element_value** ищет по тексту из атрибута value. 

