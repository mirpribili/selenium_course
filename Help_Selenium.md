
# Поиск элементов с помощью Selenium

Для поиска элементов на странице в **Selenium WebDriver** используются несколько стратегий, позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Существуют следующие методы поиска элементов:

- **find_element_by_id** - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
- **find_element_by_css_selector** - поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
- **find_element_by_xpath** - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
- **find_element_by_name** - поиск по атрибуту name элемента;
- **find_element_by_tag_name** - поиск элемента по названию тега элемента;
- **find_element_by_class_name** - поиск по значению атрибута class;
- **find_element_by_link_text** - поиск ссылки на странице по полному совпадению;
- **find_element_by_partial_link_text** - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

### Например, мы хотим найти кнопку со значением id="submit_button":
```python

from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit")
```


*Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, в которой вы запускали ваш скрипт. Скорее всего, вы увидите там ошибку NoSuchElementException. Она будет выглядеть следующим образом:*


**selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {"method":"id","selector":"submit"}**


*Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким id на странице нет.
Исправим локатор, чтобы наш код проходил без ошибок:*

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit_button")
```
#### Есть второй способ для поиска элементов с помощью универсального метода find_element() и полей класса By из библиотеки selenium. Пример:
```python
from selenium import webdriver

from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")
```

Можно использовать те же стратегии поиска, что и в **первом способе**. **Второй способ** более удобен для оформления архитектуры тестовых сценариев с помощью подхода Page Object Model, о котором мы будем говорить далее. Пока же предлагаем пользоваться первым методом с явным указанием способа поиска, так как он кажется нам более удобным, но ничто не мешает вам пользоваться и тем, и другим. Поля класса By, которые можно использовать для поиска:

- **By.ID** – поиск по уникальному атрибуту id элемента;
- **By.CSS_SELECTOR** – поиск элементов с помощью правил на основе CSS;
- **By.XPATH** – поиск элементов с помощью языка запросов XPath;
- **By.NAME** – поиск по атрибуту name элемента;
- **By.TAG_NAME** – поиск по названию тега;
- **By.CLASS_NAME** – поиск по атрибуту class элемента;
- **By.LINK_TEXT** – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
- **By.PARTIAL_LINK_TEXT** – поиск ссылки по частичному совпадению текста.

>**!Важно.** Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, подходящих под заданные вами параметры поиска. В этом случае **WebDriver вернет вам только первый элемент**, который встретит во время поиска по HTML. Если вам нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо использовать методы **find_elements_by**, которые мы рассмотрим чуть позже.

Иногда в статьях про Selenium WebDriver вы также будете встречать термин "локаторы", под которым подразумеваются стратегии поиска и значения, по которым должен выполняться поиск. Например, можно искать по локатору **By.ID со значением "send_button"**.




# Работа с браузером в Selenium
[comments](https://stepik.org/lesson/138920/step/3?unit=196194)

Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения кода. Поэтому обратите внимание на то что необходимо явно закрывать окно браузера в нашем коде при помощи команды **browser.quit()**. 

Каждый раз при открытии браузера **browser = webdriver.Chrome()** в системе создается процесс, который останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без оперативной памяти после запуска нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:
```python
from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()
```
Важно еще пояснить разницу между двумя командами: **browser.close()** и **browser.quit()**. 
*Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же?*

На самом деле, **browser.close()** закрывает текущее окно браузера. Это значит, что если ваш скрипт вызвал всплывающее окно, или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть. 

В свою очередь **browser.quit()** закрывает все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии. 

Подробнее можно посмотреть здесь: *Difference between webdriver.Dispose(), .Close() and .Quit().*

Будьте внимательны с этими методами и, в общем случае, всегда используйте **browser.quit()**. 

### Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше? 

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего использовать конструкцию 
```python
try/finally: 
```
```python

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()
```
Можете попробовать запустить оба примера и обратить внимание на разницу.

Подробно говорить об обработке исключений мы сейчас не будем, здесь важно понимать только то, что даже если в коде внутри блока **try** произойдет какая-то ошибка, то код внутри блока **finally** выполнится в любом случае. Советуем добавлять такую обработку ко всем своим скриптам при выполнении задач этого и следующего модулей, а в третьем модуле мы обсудим более лаконичные конструкции.

Если хотите узнать больше про исключения, как их кидать, ловить и как с ними жить, то советуем к прохождению вот этот урок:  [Ошибки и исключения](https://stepik.org/lesson/24463/step/1?unit=6771).



Здесь можно (и, кажется, нужно) использовать конструкцию **with ... as**:
```python
with webdriver.Chrome() as browser:
    browser.get(link)
    button = browser.find_element(By.ID, "submit")
    button.click()
```
Оно само избавится от ресурса по выходу из блока или при падении.



# Поиск всех необходимых элементов с помощью find_elements_by

Мы уже упоминали, что метод **find_element_by** возвращает только первый из всех элементов, которые подходят под условия поиска. Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки товаров в корзине интернет-магазина. 
*В тесте нам нужно проверить, что отображаются все выбранные для покупки товары.*
Для этого существуют методы **find_elements_by**, которые в отличие от **find_element_by** вернут список всех найденных элементов по заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество товаров. Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):
```python
# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера

browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину

add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# открываем страницу второго товара

browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину

add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements_by_css_selector(".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2
```
Набор стратегий здесь такой же, как и в случае с find_element_by:

- **find_elements_by_css_selector**;
- **find_elements_by_xpath**;
- **find_elements_by_name**;
- **find_elements_by_tag_name**;
- **find_elements_by_class_name**;
- **find_elements_by_link_text**;
- **find_elements_by_partial_link_text**.

Также для поиска нескольких элементов мы можем использовать универсальный метод **find_elements** вместе с атрибутами класса **By**:
```python
from selenium.webdriver.common.by import By


driver.find_elements(By.CSS_SELECTOR, "button.submit")
```
<span style='color:red'>!Важно.</span> Обратите внимание на важную разницу в результатах, которые возвращают методы **find_element** и **find_elements**. Если первый метод не смог найти элемент на странице, то он вызовет **ошибку NoSuchElementException**, которая прервёт выполнение вашего кода. **Второй же метод** всегда возвращает валидный результат: если ничего не было найдено, то он вернёт пустой список и ваша программа перейдет к выполнению следующего шага в коде.



# Как работать с элементами типа checkbox и radiobutton?
```python
<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">
```
Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с помощью значения **id** или значения атрибута **value**. Если вы видите на странице чекбокс с уникальным значением **name**, то можете искать по name.

Чтобы снять/поставить галочку в элементе типа **checkbox** или выбрать опцию из группы **radiobuttons**, надо указать **WebDriver** метод поиска элемента и выполнить для найденного элемента метод **click()**:
```python
option1 = browser.find_element_by_css_selector("[value='python']")
option1.click()
```

Также вы можете увидеть тег **label рядом с input**. Этот тег используется, чтобы сделать кликабельным текст, который отображается рядом с флажком. Этот текст заключен внутри тега **label**. Элемент **label** связывается с элементом **input** с помощью атрибута **for**, в котором указывается значение атрибута **id для элемента input**:
```python
<div>
  <input type="radio" id="python" name="language" checked>
  <label for="python">Python</label>
</div>
<div>
  <input type="radio" id="java" name="language">
  <label for="java">Java</label>
</div>
```
В этом случае можно также отметить нужный checkbox с помощью **WebDriver**, выполнив метод **click()** на элементе **label**.
```python
option1 = browser.find_element_by_css_selector("[for='python']")
option1.click()
```





# Метод get_attribute

Мы уже знаем, как найти нужный элемент на странице и как получить видимый пользователю текст. Для более детальных проверок в тесте нам может понадобиться узнать значение атрибута элемента. 
Атрибуты могут быть стандартными свойствами, которые понимает и использует браузер для отображения и вёрстки элементов или для хранения служебной информации, **например, name, width, height, color и многие другие**. Также атрибуты могут быть созданы разработчиками проекта для задания собственных стилей или правил.

**Значение атрибута представляет собой строку**. Если **значение атрибута отсутствует**, то это равносильно значению атрибута **равному "false"**. Давайте еще раз взглянем на страницу http://suninjuly.github.io/math.html. На ней есть radiobuttons, для которых выбрано значение по умолчанию. В автотесте нам может понадобиться проверить, что для одного из radiobutton по умолчанию уже выбрано значение. Для этого мы можем проверить значение атрибута checked у этого элемента. Вот HTML-код элемента:
```python
<input class="check-input" type="radio" name="ruler" id="peopleRule" value="people" checked>
```
## Найдём этот элемент с помощью WebDriver:
```python
people_radio = browser.find_element_by_id("peopleRule")
```
Найдём атрибут **"checked" с помощью встроенного метода get_attribute** и проверим его значение:
```python
people_checked = people_radio.get_attribute("checked")
print("value of people radio: ", people_checked)
assert people_checked is not None, "People radio is not selected by default"
```
Т.к. у данного атрибута значение не указано явно, то метод **get_attribute вернёт "true"**. Возможно, вы заметили, что **"true" написано с маленькой буквы**, — все методы WebDriver взаимодействуют с браузером с помощью JavaScript, в котором булевые значения пишутся с маленькой буквы, а не с большой, как в Python.

### Мы можем написать проверку другим способом, сравнив строки:
```python
assert people_checked == "true", "People radio is not selected by default"
```
Если атрибута нет, то метод **get_attribute вернёт значение None**. Применим метод get_attribute ко второму radiobutton, и убедимся, что атрибут отсутствует.
```python
robots_radio = browser.find_element_by_id("robotsRule")
robots_checked = robots_radio.get_attribute("checked")
assert robots_checked is None
```
Так же мы можем проверять наличие атрибута disabled, который определяет, может ли пользователь взаимодействовать с элементом. Например, в предыдущем задании на странице с капчей для роботов JavaScript устанавливает атрибут disabled у кнопки Submit, когда истекает время, отведенное на решение задачи.
```python
<button type="submit" class="btn btn-default" disabled>Submit</button>
```



# Работа со списками

На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных особенностей:

- У каждого элемента списка обычно есть уникальное значение атрибута value
- В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
- Визуально списки могут различаться тем, что в одном случае - варианты скрыты в [выпадающем меню](http://sun-ly.github.io/selects1.html), а в другом все варианты или их часть [видны](http://suninjuly.github.io/selects2.html)

Но для взаимодействия с любым вариантом списка мы будем использовать одни и те же методы Selenium.

 

## Посмотрим, как выглядит html для списка:

```python
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
 <option selected>--</option>
 <option value="1">Python</option>
 <option value="2">Java</option>
 <option value="3">JavaScript</option>
</select>
```

Варианты ответа задаются тегом option, значение value может отсутствовать. Можно отмечать варианты с помощью обычного метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся, а затем кликнуть на нужный вариант ответа:
```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get(link)


browser.find_element_by_tag_name("select").click()
browser.find_element_by_css_selector("option:nth-child(2)").click()
```
### Последняя строчка может выглядеть и так:
```python
browser.find_element_by_css_selector("[value='1']").click()
```
**Это не самый удобный способ, так как нам приходится делать лишний клик для открытия списка.**

**Есть более удобный способ**, для которого используется **специальный класс Select из библиотеки WebDriver**. 
- Вначале мы должны инициализировать новый объект, передав в него WebElement с тегом select. 
- Далее можно найти любой вариант из списка с помощью метода **select_by_value(value)**:

```python
from selenium.webdriver.support.ui import Select
select = Select(browser.find_element_by_tag_name("select"))
select.select_by_value("1") # ищем элемент с текстом "Python"
```

Можно использовать еще два метода: **select.select_by_visible_text("text")** и **select.select_by_index(index)**. 
- Первый способ ищет элемент по видимому тексту, например, **select.select_by_visible_text("Python")** найдёт "Python" для нашего примера.
- Второй способ ищет элемент по его индексу или порядковому номеру. Индексация начинается с нуля. Для того чтобы найти элемент с текстом "Python", нужно использовать **select.select_by_index(1)**, так как опция с индексом 0 в данном примере имеет значение по умолчанию равное "--".



# Метод execute_script

Рассмотрим еще один очень полезный и мощный метод, но он требует хотя бы минимальных знаний JavaScript. С помощью метода **execute_script** можно выполнить программу, написанную на языке JavaScript, как часть сценария автотеста в запущенном браузере. *Зачем это может понадобиться, если в автотестах мы стараемся взаимодействовать с интерфейсом сайта как обычный пользователь, нажимая кнопки, выбирая пункты меню и вводя текст в текстовые поля?*

Дело в том, что **стандартные методы, доступные в Selenium, не могут** покрыть всех возможных ситуаций работы с веб-приложением. 
- Сайты в интернете могут решать самые разные задачи, начиная от простого блога до сложных финансовых или графических приложений. 
- Разработчики имеют доступ к огромному количеству различных библиотек для решения бизнес-сценариев, что приводит к появлению на веб-странице нестандартных редакторов текстов, уникальных меню, оригинальных видео-плееров и т.д.
- Порой это приводит к тому, что для нажатия вроде бы обычной кнопки тестировщику понадобится писать настоящий JavaScript-сценарий.
- Если вы столкнулись с такой ситуацией, то в первую очередь обратитесь за помощью к вашим фронтенд-разработчикам, чтобы они подсказали  пример нужного скрипта.
- Прежде чем использовать данный скрипт в тестах, вы можете проверить, как он работает прямо в браузере, выполнив код в консоли браузера. Затем можете добавить его в ваш автотест с помощью **execute_script(javascript_code)**.

### Давайте попробуем вызвать alert в браузере с помощью WebDriver. Пример сценария:
```python
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")
```
Обратите внимание, что исполняемый **JavaScript** нужно заключать в кавычки **(двойные или одинарные)**. Если внутри скрипта вам также понадобится использовать кавычки, а для выделения скрипта вы уже используете двойные кавычки, **то в скрипте следует поставить одинарные**:
```python
browser.execute_script("document.title='Script executing';")
```
Такой формат записи тоже будет работать:
```python
browser.execute_script('document.title="Script executing";')
```
Можно с помощью этого метода выполнить сразу несколько инструкций, перечислив их через точку с запятой. Изменим сначала заголовок страницы, а затем вызовем alert:
```python
browser.execute_script("document.title='Script executing';alert('Robots at work');")
```

#### Вдруг будет кому-нибудь интересно. Выполнение JavaScript на странице - это неописанный в документации Selenium способ поиска элемента.
Вместо встроенных find_element_by... можно использовать вот такую конструкцию:
```python
element = browser.execute_script('document.getElementsByName("name")')
```
#### Так же есть конструкции:
- - getElementById
- - getElementsByTagName
- - getElementsByClassName
- - querySelector - для CSS
- - querySelectorAll - для CSS (находит все совпадения)
- - #
- - evaluate - для XPATH.

## есть 2-3 незатронутые темы. Вот они: 
- 1) я уже сталкивался с написанием тестов для django-проектов, которые использовали Angular -  и вот там, кажется, из-за "динамизма" Selenium бессилен.
- 2) столкнувшись с существованием Seleinum IDE, уже при движке F-fox-а Quantum (я думаю, Вы в курсе этой проблемы), я нашел Katalon IDE(/Studio), где с кодогенерацией на python все хорошо. Хорошо было бы бы :-)  , если бы Вы затронули и эту тему (обоих IDE).
- 3) что-нибудь на тему django/flask/ django-cms/dj-oscar  + Selenium можно? Я понимаю, что это уж слишком, и буду весьма благодарен и только за п. 1, 2. 
- 4) Наверно вообще для Степика просто курс по django бы не помешал (про курс "веб-технологии" знаю, но он не слишком хорош), и отдельно курс про многопоточность в python тоже хотелось бы (это уже к команде Степика, а не к Вам).

 **для vue.js можно cypress использовать. Как vue с Selenium дружит - сложно сказать, у нас фронтенд на ember - проблемы есть с асинхронностью, но они преодолимы**

# Пример задачи для execute_script


Давайте теперь рассмотрим реальную ситуацию, когда пользователь должен кликнуть на элемент, который внезапно оказывается перекрыт другим элементом на странице.

Для клика в WebDriver мы используем метод click(). Если элемент оказывается перекрыт другим элементом, то наша программа вызовет следующую ошибку:
```python
selenium.common.exceptions.WebDriverException: Message: unknown error: Element <button type="submit" class="btn btn-default" style="margin-bottom: 1000px;">...</button> is not clickable at point (87, 420). Other element would receive the click: <p>...</p>
```
Из описания ошибки можно понять, что указанный нами элемент нельзя кликнуть в данной точке, т.к. клик произойдёт на другом элементе с тегом **<p>**.

### Чтобы увидеть пример данной ошибки, запустите следующий скрипт:
```python
from selenium import webdriver

browser = webdriver.Chrome()
link = "https://SunInJuly.github.io/execute_script.html"
browser.get(link)
button = browser.find_element_by_tag_name("button")
button.click()
assert True
```
Теперь вы можете сами посмотреть на эту страницу и увидеть, что огромный футер действительно перекрывает нужную нам кнопку. Футером (footer) называется нижний блок, который обычно одинаков для всех страниц сайта. Чтобы понять, как решить эту проблему, нужно разобраться, как работает метод **click()**.

В первую очередь WebDriver проверит, что ширина и высота элемента больше 0, чтобы по нему можно было кликнуть.

Затем, если элемент находится за границей окна браузера, WebDriver автоматически проскроллит страницу, чтобы элемент попал в область видимости, то есть не находился за границей экрана. Но это не гарантирует того, что элемент не перекрыт другим элементом, который тоже находится в области видимости.

#### А в какую точку элемента будет происходить клик?
Selenium рассчитывает координаты центра элемента и производит клик в вычисленную точку. Это тоже приведёт к ошибке, если часть элемента всё-таки видна, но элемент перекрыт больше чем на половину своей высоты или ширины.

Если мы столкнулись с такой ситуацией, мы можем заставить браузер дополнительно проскроллить нужный элемент, чтобы он точно стал видимым.
Делается это с помощью следующего скрипта:
```python
"return arguments[0].scrollIntoView(true);"
```
Мы дополнительно передали в метод scrollIntoView аргумент true, чтобы элемент после скролла оказался в области видимости. Другие возможные параметры метода можно посмотреть [здесь:](https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView)

В итоге, чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:
```python
button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()
```
В метод execute_script мы передали текст js-скрипта и найденный элемент button, к которому нужно будет проскроллить страницу. После выполнения кода элемент button должен оказаться в верхней части страницы. Подробнее о методе [см](https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView)

Также можно проскроллить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу на 100 пикселей вниз:
```python
browser.execute_script("window.scrollBy(0, 100);")
```
<span style='color:red'>!Важно.</span> Мы не будем в этом курсе изучать, как работает JavaScript, и обойдемся только приведенным выше примером скрипта с прокруткой страницы. Для сравнения приведем скрипт на этом языке, который делает то же, что приведенный выше пример для WebDriver:
```python
// javascript
button = document.getElementsByTagName("button")[0];
button.scrollIntoView(true);
```
Можете попробовать исполнить его в консоли браузера на [странице](http://suninjuly.github.io/execute_script.html). Для этого откройте инструменты разработчика в браузере, перейдите на вкладку **консоль  (console)**, скопируйте туда этот код и нажмите Enter. Таким образом можно протестировать кусочки js кода прежде чем внедрять его в свои тесты на python. 

Обратите внимание, что в коде в WebDriver нужно использовать ключевое слово **return**. Также его нужно будет использовать, когда вы захотите получить какие-то данные после выполнения скрипта. При этом при тестировании скрипта в консоли браузера слово **return** использовать не надо.


# Загрузка файлов

﻿Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод send_keys. Только теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.

Чтобы указать путь к файлу, можно использовать стандартный модуль Python для работы с операционной системой — **os**. В этом случае ваш код не будет зависеть от операционной системы, которую вы используете. Добавление файла будет работать **и на Windows, и на Linux, и даже на MaсOS**.

Пример кода, который позволяет указать путь к файлу **'file.txt'**, находящемуся в той же папке, что и скрипт, который вы запускаете:
```python
import os 

current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла 
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)
```
Попробуйте добавить в файл отдельно команды 
```python
print(os.path.abspath(__file__)) 
print(os.path.abspath(os.path.dirname(__file__)))
```
и посмотрите на разницу. Подробнее о методах модуля os можете почитать самостоятельно в [документации:](https://docs.python.org/3/library/os.path.html). Обратите внимание, что это будет работать только при запуске кода из файла, **в интерпретаторе не сработает**.

### Если совсем непонятно что происходит, пример: 

Допустим, мы написали код скрипта и сохранили код в **lesson2_step7.py** в свой локальной папке **D:\stepik_homework**. Активируем виртуальное окружение и запускаем его **python lesson2_step7.py**. В таком случае конструкция 
```python
os.path.abspath(os.path.dirname(__file__)) 
```
вернет нам путь до директории файла с кодом, то есть **D:\stepik_homework**. В эту же папку кладем файл, который хотим прикрепить, то есть **file.txt**. Тогда, после выполнения команды:
```python
file_path = os.path.join(current_dir, 'file.txt')
```
В переменной file_path будет полный путь к файлу **'D:\stepik_homework\file.txt'**. Фишка в том, что если мы файлы **lesson2_step7.py** вместе с **file.txt** перенесем в другую папку, или на компьютер с другой ОС, то такой код без правок заработает и там. 

 

Элемент в форме, который выглядит, как кнопка добавления файла, имеет атрибут **type="file"**. Мы должны сначала найти этот элемент с помощью селектора, а затем применить к нему метод **send_keys(file_path)**.



### Alerts и как с ними жить

Мы уже встречали alert** в нашем курсе, когда получали число-ответ в задачах. Также мы узнали, что можно самостоятельно вызвать alert с помощью **JavaScript**:
```python
alert('Hello!');
```
Теперь рассмотрим ситуацию, когда в сценарии теста возникает необходимость не только получить содержимое **alert**, но и нажать кнопку OK, чтобы закрыть **alert**. 
**Alert** является модальным окном: это означает, что пользователь не может взаимодействовать дальше с интерфейсом, пока не закроет **alert**. Для этого нужно сначала переключиться на окно с **alert**, а затем принять его с помощью команды **accept()**:
```python
alert = browser.switch_to.alert
alert.accept()
```
Чтобы получить текст из **alert, используйте свойство text объекта alert**:
```python
alert = browser.switch_to.alert
alert_text = alert.text
```
Другой вариант модального окна, который предлагает пользователю выбор согласиться с сообщением или отказаться от него, называется **confirm**. Для переключения на окно confirm используется та же команда, что и в случае с **alert**:
```python
confirm = browser.switch_to.alert
confirm.accept()
```
Для **confirm-окон** можно использовать следующий **метод для отказа**:
```python
confirm.dismiss()
```
То же самое, что и при нажатии пользователем кнопки "Отмена". 

Третий вариант модального окна — **prompt — имеет дополнительное поле для ввода текста**. Чтобы ввести текст, используйте метод **send_keys()**:
```python
prompt = browser.switch_to.alert
prompt.send_keys("My answer")
prompt.accept()
```
<img alt="" src="https://ucarecdn.com/9a1f5aa3-d1b6-42c0-b340-a18e966c7a1b/" width="448" height="182">


**pyperclip** помог, спасибо!
```python
alert = browser.switch_to.alert
alert_text = alert.text
addToClipBoard = alert_text.split(': ')[-1]
pyperclip.copy(addToClipBoard)
```
и число в буфере обмена.

### а как обратиться теперь к этому числу в буфере?

забрать результат из **alert**
```python
alert_text.split(': ')[-1]
```
юзай эту [библиотеку](https://pypi.org/project/pyperclip/)

Как то так:
выполнения команды:
```python
>>> import pyperclip
>>> pyperclip.copy('The text to be copied to the clipboard.')
>>> pyperclip.paste()
'The text to be copied to the clipboard.'
```

Только зачем, если из теста вставлять число в ответ, то просто используй .send_keys(имя_переменной_с_результатом) и **pyperclip** с буфером обмена не нужен. [Вот](https://github.com/VitaliyYa/sendToStepik) как я делал.
Или [вот](https://github.com/VitaliyYa/sendToStepik/blob/master/auth.py)